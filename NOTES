Se tivéssemos que esperar uma música terminar para poder abrir nosso navegador, ou se tivéssemos que reiniciar o computador para matar um programa preso em um loop infinito, morreríamos de frustração!

Um thread de execução é uma sequência lógica de instruções dentro de um processo que é automaticamente gerenciado pelo kernel do sistema operacional. Um programa sequencial regular tem um único thread, mas os sistemas operacionais modernos nos permitem criar vários threads em nossos programas, todos os quais rodam em paralelo.

Cada um dos threads de um processo tem seu próprio contexto: seu próprio ID, sua própria pilha, seu próprio ponteiro de instrução, seu próprio registrador de processador. Mas como todos os threads são parte do mesmo processo, eles compartilham o mesmo espaço de endereço de memória virtual: o mesmo código, o mesmo heap, as mesmas bibliotecas compartilhadas e os mesmos descritores de arquivo aberto.

O contexto de um thread tem uma pegada menor em termos de recursos do que o contexto de um processo. O que significa que é muito mais rápido para o sistema criar um thread do que criar um processo. Alternar de um thread para o outro, comparado a alternar de um processo para outro, também é mais rápido.

Os threads não têm a hierarquia estrita pai-filho que os processos têm. Em vez disso, eles formam um grupo de pares, independentemente de qual thread criou qual outra thread. A única distinção que a thread “principal” tem é ser a primeira a existir no início do processo. Isso significa que, dentro do mesmo processo, qualquer thread pode esperar que qualquer outra thread seja concluída ou matar qualquer outra thread.

Além disso, qualquer thread pode ler e escrever na mesma memória virtual, o que torna a comunicação entre threads muito mais fácil do que a comunicação entre processos. Mais tarde, examinaremos os problemas que podem surgir dessa memória compartilhada.

Uma das maiores qualidades dos threads é que todos eles compartilham a memória de seus processos. Cada thread tem sua própria pilha, mas os outros threads podem facilmente obter acesso a ela com um simples ponteiro. Além do mais, o heap e quaisquer descritores de arquivo abertos são totalmente compartilhados entre os threads.

Essa memória compartilhada e a facilidade com que um thread pode acessar a memória de outro thread claramente também têm sua parcela de perigo: podem causar erros de sincronização desagradáveis.

The Philosophers project from 42 School is a classic exercise in concurrent programming, designed to teach students about threads, mutexes, and the principles of synchronization in a system where multiple operations occur simultaneously. It is based on the famous Dining Philosophers Problem, originally formulated by Edsger Dijkstra, which explores the challenges of resource sharing and deadlocks in concurrent processes.

Key Concepts in the Philosophers Project:
The Problem:

Imagine a group of philosophers seated around a table. Between each pair of philosophers, there is a fork. The philosophers alternate between thre activities: thinking, eating and sleeping.
In order to eat, a philosopher must pick up the two forks adjacent to them (one on their left and one on their right).
The challenge lies in coordinating the philosophers such that no two neighboring philosophers are holding the same fork at the same time, without leading to deadlock (where no one can eat because each philosopher is holding one fork and waiting for the other).
Concurrency and Threads:

Each philosopher is represented by a thread, which allows multiple philosophers to think, eat and sleep concurrently.
Threads run independently, and you need to ensure that operations (like picking up and putting down forks) are synchronized to avoid race conditions (where multiple threads access shared resources at the same time).

Mutexes:

Mutexes (short for mutual exclusion locks) are used to manage access to the shared resources (forks in this case). They ensure that only one philosopher can hold a fork at any given time.
By locking the fork when a philosopher picks it up and unlocking it when they put it down, mutexes prevent other philosophers from picking up the same fork simultaneously.
Deadlocks and Starvation:

The main challenges in the project are deadlocks (where all threads are waiting indefinitely for a resource) and starvation (where some philosophers never get a chance to eat because others monopolize the forks).
The project teaches techniques to avoid these issues, such as:
Ordering resource acquisition: Philosophers might be required to pick up the forks in a specific order.
Time limits: You can implement timeouts for how long a philosopher can wait for a fork before putting down any they already hold.
Synchronization:

Ensuring that threads synchronize properly (for instance, waiting until both forks are available before eating) is a crucial aspect of the project. This prevents inconsistent states where a philosopher is trying to eat without having the necessary forks.
Lessons Learned:
The Philosophers project helps students grasp essential principles of multithreading, resource management, and synchronization. It emphasizes how careful planning is required to ensure that systems with multiple concurrent operations run smoothly and without conflicts. This project is a stepping stone to understanding more complex synchronization mechanisms in real-world operating systems.











